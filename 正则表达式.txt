正则表达式：RegExp
1、var reg = /内容/属性;直接量创建。加属性i:忽视大小写匹配。
	加g：全局匹配，查找所有匹配，并非找到第一个匹配后停止。加m：多行匹配
reg1 = new RegExp("内容"或者已知reg，属性i/g/m);
假如reg1 = RegExp(reg);不new的话。两者引用相等。


var reg = /abc/, str = 'abcdf';
reg.test(str);判断str有没有符合reg中的片段，返回结果为ture/false
str.match(reg);判断str有没有符合reg中的片段，返回结果为匹配到的片段

2、表达式(一个表达式为一位)/[abc][123][^qwe]/第一位只能是abc中一位，第二位只能是123，第三位不能有qwe任何一位
[0-9]：查找任何从0-9的数字
[a-z]：查找任何从a-z的字符
[A-Z]：查找任何从A-Z的字符
[A-z]：查找任何从大写A-z的字符
[^a]：^尖角号在表达式里表示非,比如这里就表示非a任何字符
(red|bule|green)：查找有没有red或者bule或者green的片段
(r|b|g)e：查找有没有red或者bule或者green的片段

3、元字符
.  === [^\r\n]只要不是回车符和换行符
\w === [0-9A-z_]数字、字母、下划线
\W === [^\w]

\d === [0-9]数字
\D === [^\d]

\s === [\t\n\r\v\f ]查找空白字符，有空格、制表符\t、回车符\r、换行符\n、垂直换行符\v、换页符\f
\S 查找非空白字符

\b 匹配单词边界[\babc\b]ac为单词边界 'abc fgh'
\B 匹配非单词边界

4、量词
n+：出现1次到无数次
n*：出现0次到无数次
n?: 出现0次或者1次
n{X}: 出现X个n的匹配
n{X,}: 出现至少X个n的匹配
n{X,Y}: X<=Y，至少X次，最多Y次

正向预查：?=n匹配任何后面是n的字符串
?!n，匹配后面不是n的字符串

n$:以n为结尾
^n:以n开头

属性：
lastIndex:一个整数，与exec()配合，显示 当前游标位置

方法：
.test()：检索字符串中指定的值，返回ture或false
.exec()：检索字符串中指定的值，返回找到的值，并确定其位置*
.compile()：编译正则表达式

子表达式(内容)
/(a)\1/  \1:反向引用第一个子表达式里的内容   /(\w)\1/,假如\w匹配到了a,那么\1也只能匹配a
/(a)\1(b)\2/  \2:反向引用第二个子表达式里的内容
以此类推 

支持正则表达式的String对象的方法
search:检索与正则表达式相匹配的值
match：找到一个或多个正则表达式的匹配
replace：替换与正则表达式匹配的子串
split：把字符串分割为字符串数组


重点：
exec
子表达式
replace（reg，'要替换的字符串'）